<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="H's blog" href="https://1lunarveil.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="H's blog" href="https://1lunarveil.github.io/atom.xml"><link rel="alternate" type="application/json" title="H's blog" href="https://1lunarveil.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="ai"><link rel="canonical" href="https://1lunarveil.github.io/2025/10/20/%E5%8D%8E%E4%B8%BAAI%E5%B2%97-%E7%AC%94%E8%AF%95/"><title>华为AI岗--笔试（一） | H-solo = H's blog = Weclome</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">华为AI岗--笔试（一）</h1><div class="meta"><span class="item" title="创建时间：2025-10-20 23:36:21"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2025-10-20T23:36:21+08:00">2025-10-20</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>7.3k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>7 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">H-solo</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="/images/bg/9.jpg"></li><li class="item" data-background-image="/images/bg/34.jpg"></li><li class="item" data-background-image="/images/bg/46.jpg"></li><li class="item" data-background-image="/images/bg/17.jpg"></li><li class="item" data-background-image="/images/bg/19.jpg"></li><li class="item" data-background-image="/images/bg/2.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://1lunarveil.github.io/2025/10/20/%E5%8D%8E%E4%B8%BAAI%E5%B2%97-%E7%AC%94%E8%AF%95/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="1LunarVeil"><meta itemprop="description" content="Weclome, A personal blog of a computer novice"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="H's blog"></span><div class="body md" itemprop="articleBody"><p>今晚偶然间看到的nju_spy大佬更新的博客，发现是细糠，考虑到后面可能会出现找不到的情况，特意转载至此，方便以后查找观看，同时强烈推荐想学习ai的朋友们去看看nju_spy大佬更新的博客</p><hr><h1 id="目录"><a class="anchor" href="#目录">#</a> 目录</h1><h1 id="一-华为代码题"><a class="anchor" href="#一-华为代码题">#</a> 一、华为代码题</h1><ol><li><h2 id="dbscan-聚类-1010"><a class="anchor" href="#dbscan-聚类-1010">#</a> DBSCAN 聚类 （10.10）</h2></li><li><h2 id="实现masked-multi-head-self-attention-928"><a class="anchor" href="#实现masked-multi-head-self-attention-928">#</a> 实现Masked Multi-Head Self-Attention （9.28）</h2></li></ol><h1 id="二-代码题读入格式"><a class="anchor" href="#二-代码题读入格式">#</a> 二、代码题读入格式</h1><h1 id="三-选择题"><a class="anchor" href="#三-选择题">#</a> 三、选择题</h1><h1 id="一-华为代码题-2"><a class="anchor" href="#一-华为代码题-2">#</a> 一、华为代码题</h1><ol><li><h2 id="dbscan-聚类-1010-2"><a class="anchor" href="#dbscan-聚类-1010-2">#</a> DBSCAN 聚类 （10.10）</h2><ul><li>任务: 用DBSCAN在二维或三维实数坐标上做聚类，输出“簇的数量”和“噪声点数量”。</li><li>定义: 距离为欧氏距离；某点的邻域半径为eps；若该点邻域内样本数（含自身）≥ min_samples，则为<strong>核心点</strong>；从未访问核心点出发，<strong>按邻域可达关系扩展一个簇</strong>；不被任何簇吸收的点视为噪声</li></ul><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">euclidean_distance</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> math.sqrt(<span class="built_in">sum</span>((x - y) ** <span class="number">2</span> <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(a, b)))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    eps, min_samples, x = <span class="built_in">input</span>().split()</span><br><span class="line">    eps = <span class="built_in">float</span>(eps)</span><br><span class="line">    min_samples = <span class="built_in">int</span>(min_samples)</span><br><span class="line">    x = <span class="built_in">int</span>(x)</span><br><span class="line">     </span><br><span class="line">    points = [] <span class="comment"># 读入点集</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(x):</span><br><span class="line">        coords = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">float</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">        points.append(coords)</span><br><span class="line">     </span><br><span class="line">    cluster_count, noise_count = dbscan(points, eps, min_samples)</span><br><span class="line">    <span class="built_in">print</span>(cluster_count, noise_count)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p></p></li></ol><p>思路 -- 对每个未访问点：</p><ul><li><p>找它的邻域（距离 ≤ eps）</p></li><li><p>如果邻域内点数 &lt; min_samples，标记为噪声（但噪声可能后来被重新归类到簇中，如果它是某个核心点的邻域点）</p></li><li><p>如果邻域内点数 ≥ min_samples，则它是核心点，以它开始扩展新簇：</p></li><li><p>​ 把邻域内所有点加入该簇</p></li><li><p>​ 对邻域内每一个未访问点，递归检查是否为核心点，如果是，把它的邻域也加入簇</p></li></ul><p>region_query 邻域点， 可用来判断是否为核心点。</p><p>seeds 代表待用来扩展的点。初始为当前核心点 p_idx 的邻域。</p><p>while循环 每次用seeds的头 q_idx 扩展未被访问过的邻域点q：</p><p>若 q 是核心点，根据“邻域可达” 把 q 的邻域未访问的点也加入 seed。</p><p>操作完后，对刚刚的头 q_idx，如果之前没被标记过标记为 p_idx。</p><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dbscan</span>(<span class="params">points, eps, min_samples</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(points)</span><br><span class="line">    visited = [<span class="literal">False</span>] * n</span><br><span class="line">    cluster_id = [-<span class="number">1</span>] * n  <span class="comment"># -1 表示未分类或噪声</span></span><br><span class="line">    clusters = []</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">region_query</span>(<span class="params">p_idx</span>):</span><br><span class="line">        <span class="comment"># 返回邻域内的点的索引列表</span></span><br><span class="line">        neighbors = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> euclidean_distance(points[p_idx], points[i]) &lt;= eps:</span><br><span class="line">                neighbors.append(i)</span><br><span class="line">        <span class="keyword">return</span> neighbors</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">expand_cluster</span>(<span class="params">p_idx, cluster_label</span>):</span><br><span class="line">        <span class="comment"># 从核心点 p_idx 扩展簇</span></span><br><span class="line">        cluster_points = [p_idx]</span><br><span class="line">        visited[p_idx] = <span class="literal">True</span></span><br><span class="line">        cluster_id[p_idx] = cluster_label</span><br><span class="line">         </span><br><span class="line">        <span class="comment"># 种子集合</span></span><br><span class="line">        seeds = region_query(p_idx)</span><br><span class="line">        seeds.remove(p_idx)  <span class="comment"># 自己已经处理过</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span> seeds:</span><br><span class="line">            q_idx = seeds.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[q_idx]:</span><br><span class="line">                visited[q_idx] = <span class="literal">True</span></span><br><span class="line">                q_neighbors = region_query(q_idx)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(q_neighbors) &gt;= min_samples:</span><br><span class="line">                    <span class="comment"># q 也是核心点，将其邻域中未访问的加入 seeds</span></span><br><span class="line">                    <span class="keyword">for</span> n_idx <span class="keyword">in</span> q_neighbors:</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> visited[n_idx] <span class="keyword">and</span> n_idx <span class="keyword">not</span> <span class="keyword">in</span> seeds:</span><br><span class="line">                            seeds.append(n_idx)</span><br><span class="line">            <span class="keyword">if</span> cluster_id[q_idx] == -<span class="number">1</span>:</span><br><span class="line">                cluster_id[q_idx] = cluster_label</span><br><span class="line">                cluster_points.append(q_idx)</span><br><span class="line">        clusters.append(cluster_points)</span><br><span class="line">     </span><br><span class="line">    label = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> visited[i]:</span><br><span class="line">            neighbors = region_query(i)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(neighbors) &lt; min_samples:</span><br><span class="line">                <span class="comment"># 标记为噪声（可能之后被核心点拉入簇）</span></span><br><span class="line">                cluster_id[i] = -<span class="number">1</span>  <span class="comment"># 噪声</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 核心点，开始扩展簇</span></span><br><span class="line">                expand_cluster(i, label)</span><br><span class="line">                label += <span class="number">1</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment"># 统计噪声点：最终 cluster_id 仍为 -1 的点</span></span><br><span class="line">    noise_count = <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">for</span> cid <span class="keyword">in</span> cluster_id <span class="keyword">if</span> cid == -<span class="number">1</span>)</span><br><span class="line">    cluster_count = label  <span class="comment"># label 是已分配的簇数</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> cluster_count, noise_count</span><br></pre></td></tr></table></figure><p></p><ol start="2"><li><h2 id="实现masked-multi-head-self-attention-928-2"><a class="anchor" href="#实现masked-multi-head-self-attention-928-2">#</a> 实现Masked Multi-Head Self-Attention （9.28）</h2></li></ol><p>给定批量序列表示 X（形状：[batch, seq, d_model]）与权重矩阵 W_Q、W_K、W_V、W_O（均为 d_model×d_model），实现 Masked Multi-Head Self-Attention。</p><p><strong>将最后一维按头数 num_heads 均分</strong>，每头维度 d_k = d_model / num_heads。<br>计算步骤：</p><ol><li><p>Q = X @ W_Q，K = X @ W_K，V = X @ W_V。</p></li><li><p>将 **Q、K、V reshape 为 [batch, num_heads, seq, d_k]。 **</p></li><li><p>计算注意力分数 scores = (Q @ K^T) / sqrt(d_k)，其中 K^T 表示每头在最后两维做转置；乘法得到得到 [batch, num_heads, seq, seq]。</p></li><li><p>使用下三角因果<strong>掩码</strong>（只能看见当前及更早位置）：掩掉<strong>上三角元素</strong>（置为一个很小的负数）。</p></li><li><p>在最后一维做 softmax 得到权重，注意<strong>数值稳定性（减去每行最大值</strong>再做 exp）。</p></li><li><p>attention = softmax @ V（形状 [batch, num_heads, seq, d_k]）。</p></li><li><p>**拼回 [batch, seq, d_model] **后，再右乘 W_O。<br>输出保留两位小数，结果需转换为 Python List。</p><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">x, axis=-<span class="number">1</span></span>):</span><br><span class="line">    <span class="comment"># 数值稳定 softmax</span></span><br><span class="line">    x_max = x.<span class="built_in">max</span>(axis=axis, keepdims=<span class="literal">True</span>)</span><br><span class="line">    e_x = np.exp(x - x_max)</span><br><span class="line">    <span class="keyword">return</span> e_x / e_x.<span class="built_in">sum</span>(axis=axis, keepdims=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 输入格式 分号分割</span></span><br><span class="line">    parts = data_str.split(<span class="string">&#x27;;&#x27;</span>)</span><br><span class="line">    num_heads = <span class="built_in">int</span>(parts[<span class="number">0</span>].strip())</span><br><span class="line">    X = <span class="built_in">eval</span>(parts[<span class="number">1</span>].strip())</span><br><span class="line">    W_Q = <span class="built_in">eval</span>(parts[<span class="number">2</span>].strip())</span><br><span class="line">    W_K = <span class="built_in">eval</span>(parts[<span class="number">3</span>].strip())</span><br><span class="line">    W_V = <span class="built_in">eval</span>(parts[<span class="number">4</span>].strip())</span><br><span class="line">    W_O = <span class="built_in">eval</span>(parts[<span class="number">5</span>].strip())</span><br><span class="line">    </span><br><span class="line">    result = masked_multi_head_attention(num_heads, X, W_Q, W_K, W_V, W_O)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p></p><p>按题目要求进行 多头结构，上三角 mask 为负无穷，再尺度变回来</p></li></ol><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">masked_multi_head_attention</span>(<span class="params">num_heads, X, W_Q, W_K, W_V, W_O</span>):</span><br><span class="line">    X = np.array(X, dtype=np.float32)</span><br><span class="line">    W_Q = np.array(W_Q, dtype=np.float32)</span><br><span class="line">    W_K = np.array(W_K, dtype=np.float32)</span><br><span class="line">    W_V = np.array(W_V, dtype=np.float32)</span><br><span class="line">    W_O = np.array(W_O, dtype=np.float32)</span><br><span class="line">    </span><br><span class="line">    batch, seq_len, d_model = X.shape</span><br><span class="line">    d_k = d_model // num_heads</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 1) Q, K, V</span></span><br><span class="line">    Q = X @ W_Q  <span class="comment"># [batch, seq_len, d_model]</span></span><br><span class="line">    K = X @ W_K</span><br><span class="line">    V = X @ W_V</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2) reshape to multi-head</span></span><br><span class="line">    Q = Q.reshape(batch, seq_len, num_heads, d_k).transpose(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>)  <span class="comment"># [batch, num_heads, seq_len, d_k]</span></span><br><span class="line">    K = K.reshape(batch, seq_len, num_heads, d_k).transpose(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">    V = V.reshape(batch, seq_len, num_heads, d_k).transpose(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3) scores</span></span><br><span class="line">    scores = Q @ K.transpose(<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>)  <span class="comment"># [batch, num_heads, seq_len, seq_len]</span></span><br><span class="line">    scores /= math.sqrt(d_k)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 4) causal mask</span></span><br><span class="line">    mask = np.triu(np.ones((seq_len, seq_len), dtype=np.bool_), k=<span class="number">1</span>)  <span class="comment"># 上三角（不含对角线）为 True</span></span><br><span class="line">    scores = scores + (mask * -<span class="number">1e9</span>)  <span class="comment"># 上三角置为 -1e9</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 5) softmax</span></span><br><span class="line">    attn_weights = softmax(scores, axis=-<span class="number">1</span>)  <span class="comment"># [batch, num_heads, seq_len, seq_len]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 6) attention output</span></span><br><span class="line">    attention = attn_weights @ V  <span class="comment"># [batch, num_heads, seq_len, d_k]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 7) concat heads</span></span><br><span class="line">    attention = attention.transpose(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>).reshape(batch, seq_len, d_model)  <span class="comment"># [batch, seq_len, d_model]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 8) output projection</span></span><br><span class="line">    output = attention @ W_O  <span class="comment"># [batch, seq_len, d_model]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 保留两位小数</span></span><br><span class="line">    output_rounded = np.<span class="built_in">round</span>(output, <span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> output_rounded.tolist()</span><br></pre></td></tr></table></figure><p></p><p>比较奇怪的是，样例这样全是整数的情况，要求保留两位小数，numpy删除了后面多余的0.</p><p>（所以需要重写输出格式）</p><h2 id="二-代码题读入格式-2"><a class="anchor" href="#二-代码题读入格式-2">#</a> 二、代码题读入格式</h2><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取单行字符串/整数</span></span><br><span class="line">s = <span class="built_in">input</span>().strip()</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>().strip())</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 一行整数数列</span></span><br><span class="line">arr = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 读取多行字符串</span></span><br><span class="line"> </span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>().strip())</span><br><span class="line">strings = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    strings.append(<span class="built_in">input</span>().strip())</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 读取二维整数列表</span></span><br><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()) <span class="comment"># 两个整数</span></span><br><span class="line">matrix = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    row = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    matrix.append(row)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">3 4</span></span><br><span class="line"><span class="string">1 2 3 4</span></span><br><span class="line"><span class="string">5 6 7 8</span></span><br><span class="line"><span class="string">9 10 11 12</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 读带[] 的列表格式使用 eval</span></span><br><span class="line">matrix = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">matrix = np.array(<span class="built_in">eval</span>(<span class="built_in">input</span>()))</span><br><span class="line"><span class="comment"># 输入: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 保留小数控制格式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;π的值: <span class="subst">&#123;math.pi:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p></p><h2 id="三-选择题-2"><a class="anchor" href="#三-选择题-2">#</a> 三、选择题</h2><p>1.在大型语言模型的三阶段训练流程中，哪一个阶段的主要目标是让只会“续写”文本的基座模型变为<strong>能理解并遵循人类指令格式的“对话助手”？</strong></p><p>A 预训练 (Pre-training)</p><p><strong>B 有监督微调 (Supervised Fine-Tuning, SFT)</strong></p><p>C 奖励模型训练 (Reward Model Training)</p><p>D 基于人类反馈的强化学习 (RLHF)</p><p>解析：B</p><pre><code>1.预训练 (Pre-training)
使用海量文本训练模型，获得语言建模能力（即“续写”能力），但此时模型并不懂得人类指令或对话格式。

2.有监督微调 (SFT)
使用高质量的指令-回答对数据，让模型学会遵循指令、进行对话。这直接让模型从“续写文本”变成“对话助手”。

3.奖励模型训练 (RM Training)
训练一个打分模型，用于评估生成结果的质量，为 RLHF 阶段提供奖励信号。

4.基于人类反馈的强化学习 (RLHF)
利用 RM 对模型输出进行评分，通过强化学习进一步优化模型，使其输出更符合人类偏好。
</code></pre><p>题目问的是<strong>主要目标</strong>是让“续写”模型变为“对话助手”的阶段，这个转变主要发生在 SFT 阶段，因为 SFT 直接教会模型指令遵循和对话格式。</p><ol start="3"><li>对于 3×224×224 输入，卷积核 7×7、stride=2、padding=3、输出通道64，输出特征图的空间尺寸为（ ）</li></ol><p>对于每个维度 <img data-src="https://cdn.jsdelivr.net/gh/1LunarVeil/Picture-bed@main/img/202510202323649.png" alt="74aa55ffa3c04f90a3d3fff227fe4b22"></p><p>(224+2<em>3-7) / 2 +1 所以为 112</em>112</p><ol start="4"><li>连续掷一枚均匀硬币，<strong>首次出现“正反”序列</strong>（一次正面后立刻反面）所需的<strong>期望掷币次数为</strong>（ ）</li></ol><p>定义 初态，中间态，结束态，进行转化。</p><ul><li><p>E：从初始状态（没有前置投掷）开始，到出现“正反”所需的期望次数。</p></li><li><p>EH：在刚刚掷出一个**H（正面）**的情况下，到出现“正反”所需的期望次数</p></li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/1LunarVeil/Picture-bed@main/img/202510202324696.png" alt="cf022ab309b64fcb994ef35ff579f3e6"> 扔到反是E ；扔到正是 EH</p><p><img data-src="https://cdn.jsdelivr.net/gh/1LunarVeil/Picture-bed@main/img/202510202324391.png" alt="a7bea0974db64db9a9495f1f787858f0"> 扔到反直接结束，扔到正还需要 EH次</p><ol start="5"><li><p>在 Stacking 集成学习中：</p><ul><li><p><strong>第一层</strong>：多个<strong>基模型</strong>对训练数据进行预测（通常用交叉验证方式得到 out-of-fold 预测值）。</p></li><li><p><strong>第二层</strong>（Meta-Model / <strong>元模型</strong>）：将第一层基模型的<strong>预测结果作为输入特征</strong>，学习如何最优地<strong>组合这些预测</strong>，以得到最终预测。</p></li></ul></li></ol><p>因此，第二层模型的作用是 <strong>学习基模型预测的组合方式</strong>，而不是简单加权平均（那是加权投票或 Blending 的做法），也不是优化基模型的参数（基模型参数训练在第一层已完成），也不是单纯的特征组合（它学习的是组合权重或更复杂的映射关系）。</p><ol start="6"><li></li></ol><table><thead><tr><th>特性</th><th>Tokenizer</th><th>Embedding</th></tr></thead><tbody><tr><td><strong>输入</strong></td><td>原始文本字符串</td><td>Token ID（整数）</td></tr><tr><td><strong>输出</strong></td><td>Token ID 序列</td><td>向量序列（浮点数）</td></tr><tr><td><strong>是否可训练</strong></td><td>一般固定（无参数）</td><td>可训练（有参数）</td></tr><tr><td><strong>作用阶段</strong></td><td>数据预处理 / 模型输入前</td><td>模型的第一层</td></tr><tr><td><strong>主要目标</strong></td><td>分割文本、建立词表</td><td>将符号转为数值表示、捕获语义</td></tr></tbody></table><p>7.<strong>欠定</strong>线性方程 y = A x（A 为行满秩胖矩阵），在解集中二范数最小的解为（ ）</p><p><img data-src="https://cdn.jsdelivr.net/gh/1LunarVeil/Picture-bed@main/img/202510202327669.png" alt="9e30db70d5664e20bb78f0928d42492c">伪逆 <img data-src="https://cdn.jsdelivr.net/gh/1LunarVeil/Picture-bed@main/img/202510202327138.png" alt="450466e184e34edfb3a53db37524a5b9"></p><ol start="8"><li>为缓解深层网络的<strong>梯度消失</strong>，以下激活函数更有效的是（）。</li></ol><p>A .Softmax B .Sigmoid C .Tanh D .ReLU</p><p><strong>A.Softmax</strong><br>主要用于多类分类的输出层，将输出转化为<strong>概率分布</strong>，并不是隐藏层的激活函数，对梯度消失的缓解无直接作用。</p><p><strong>B.Sigmoid</strong><br>输出范围 (0, 1)，<strong>导数最大 0.25</strong>，在饱和区接近 0，梯度消失问题严重。</p><p><strong>C.Tanh</strong><br>输出范围 (-1, 1)，导数范围 (0, 1]，<strong>在饱和区梯度会接近 0</strong>，虽然比 Sigmoid 的梯度更大一些（因为均值0，收敛更快），但仍然<strong>存在梯度消失问题</strong>，尤其在深层网络。</p><p><strong>D.ReLU</strong><br>在<strong>正区梯度恒为 1</strong>，不会因激活函数本身导致梯度衰减（无饱和区），能有效缓解梯度消失。但可能有神经元死亡问题（负半区梯度为 0）。</p><ol start="9"><li>混合精度训练中引入**“损失缩放”**的主要原因是（）。</li></ol><p>在混合精度训练中，使用 FP16 表示时，梯度的值可能非常小（小于 FP16 能表示的最小正数 ~ 6e-8），导致在反向传播时<strong>梯度变为 0</strong>，这种现象称为<strong>梯度下溢</strong>。</p><p><strong>损失缩放（Loss Scaling）</strong> 的做法是在计算损失函数后，将其乘以一个<strong>缩放因子（如 1024）</strong>，这样在<strong>反向传播时梯度也会等比例放大</strong>，使其进入 FP16 的可表示范围，避免下溢。在权重更新前，再将梯度按同样比例缩小回来。</p><p>因此，主要原因是 <strong>B 防止低精度下梯度下溢为零</strong>。</p><ol start="10"><li>内存计算：在一个由 8 张 A100-80GB 组成的集群上，上线双塔检索：文档塔输出 d 维 float32 向量，文档库 2 亿条，所有向量需常驻显存，且不能用 CPU/磁盘缓存；单卡可用显存约 75GB。问在不压缩、不量化、不断层拆分的前提下，d 的上限？</li></ol><p>75G * 8 = 600 * 1e9 B &gt; d*4B(float32) *2e8</p><p>11.关于 Causal Mask说法正确的是？</p><p>A 是一个上三角为 −∞ 的矩阵</p><p>B 防止训练时看到未来信息</p><p>C 仅用于<strong>文本生成</strong>任务 （错，音频、图像等也可，不只是文本）</p><p>D 用于增强自注意力的<strong>局部性</strong>（错，强调不看后面，前面都可以看，而不是小局部）<br>————————————————</p><p>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，下文附上原文出处链接和本声明。</p><p>原文链接：</p><p>[]: <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25qdV9zcHkvYXJ0aWNsZS9kZXRhaWxzLzE1MzI1NDAyNQ==">https://blog.csdn.net/nju_spy/article/details/153254025</span></p><div class="tags"><a href="/tags/ai/" rel="tag"><i class="ic i-tag"></i> ai</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2025-10-20 23:57:15" itemprop="dateModified" datetime="2025-10-20T23:57:15+08:00">2025-10-20</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="1LunarVeil 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="1LunarVeil 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="1LunarVeil 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>1LunarVeil： </strong>1LunarVeil <i class="ic i-at"><em>@</em></i>H's blog</li><li class="link"><strong>本文链接：</strong> <a href="https://1lunarveil.github.io/2025/10/20/%E5%8D%8E%E4%B8%BAAI%E5%B2%97-%E7%AC%94%E8%AF%95/" title="华为AI岗--笔试（一）">https://1lunarveil.github.io/2025/10/20/华为AI岗-笔试/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2025/10/15/AI%E5%AE%89%E5%85%A8%E6%9C%89%E5%85%B3%E6%9C%AF%E8%AF%AD%E5%92%8C%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E6%95%B4%E5%90%88/" itemprop="url" rel="prev" data-background-image="&#x2F;images&#x2F;bg&#x2F;7.jpg" title="AI安全有关术语和知识点的整合"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>AI安全有关术语和知识点的整合</h3></a></div><div class="item right"><a href="/2025/11/19/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="next" data-background-image="&#x2F;images&#x2F;bg&#x2F;37.jpg" title="Java学习笔记——入门篇"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>Java学习笔记——入门篇</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-%E5%8D%8E%E4%B8%BA%E4%BB%A3%E7%A0%81%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">一、华为代码题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dbscan-%E8%81%9A%E7%B1%BB-1010"><span class="toc-number">2.1.</span> <span class="toc-text">DBSCAN 聚类 （10.10）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0masked-multi-head-self-attention-928"><span class="toc-number">2.2.</span> <span class="toc-text">实现Masked Multi-Head Self-Attention （9.28）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-%E4%BB%A3%E7%A0%81%E9%A2%98%E8%AF%BB%E5%85%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">二、代码题读入格式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-%E9%80%89%E6%8B%A9%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">三、选择题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-%E5%8D%8E%E4%B8%BA%E4%BB%A3%E7%A0%81%E9%A2%98-2"><span class="toc-number">5.</span> <span class="toc-text">一、华为代码题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dbscan-%E8%81%9A%E7%B1%BB-1010-2"><span class="toc-number">5.1.</span> <span class="toc-text">DBSCAN 聚类 （10.10）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0masked-multi-head-self-attention-928-2"><span class="toc-number">5.2.</span> <span class="toc-text">实现Masked Multi-Head Self-Attention （9.28）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E4%BB%A3%E7%A0%81%E9%A2%98%E8%AF%BB%E5%85%A5%E6%A0%BC%E5%BC%8F-2"><span class="toc-number">5.3.</span> <span class="toc-text">二、代码题读入格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E9%80%89%E6%8B%A9%E9%A2%98-2"><span class="toc-number">5.4.</span> <span class="toc-text">三、选择题</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="1LunarVeil" data-src="/images/avatar.jpg"><p class="name" itemprop="name">1LunarVeil</p><div class="description" itemprop="description">A personal blog of a computer novice</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">12</span> <span class="name">文章</span></a></div><div class="item tags"><a href="/tags/"><span class="count">4</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tLzFMdW5hclZlaWw=" title="https:&#x2F;&#x2F;github.com&#x2F;1LunarVeil"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTkyMTM1MzE1NDI=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;9213531542"><i class="ic i-cloud-music"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>links</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2025/10/15/AI%E5%AE%89%E5%85%A8%E6%9C%89%E5%85%B3%E6%9C%AF%E8%AF%AD%E5%92%8C%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E6%95%B4%E5%90%88/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2025/11/19/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2025/09/21/vmware/" title="vmware">vmware</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2025/10/15/vmware3/" title="vmware3">vmware3</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2025/03/26/hello-world/" title="Hello hexo">Hello hexo</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2025/11/19/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Java学习笔记——入门篇">Java学习笔记——入门篇</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2025/10/20/%E5%8D%8E%E4%B8%BAAI%E5%B2%97-%E7%AC%94%E8%AF%95/" title="华为AI岗--笔试（一）">华为AI岗--笔试（一）</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2025/12/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%88%A4%E6%96%AD%E7%AF%87/" title="Java学习笔记——判断篇">Java学习笔记——判断篇</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2025/10/15/AI%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/" title="AI安全学习">AI安全学习</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2025/12/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%E7%AF%87/" title="Java学习笔记——方法篇">Java学习笔记——方法篇</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2025/10/11/vmware2/" title="vmware2">vmware2</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2025/09/18/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B8%B8%E7%94%A8%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD/" title="渗透测试常用专业术语">渗透测试常用专业术语</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">1LunarVeil @ H-solo</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">69k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">1:03</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2025/10/20/华为AI岗-笔试/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>